
# 課題３


## 概要

[ACM ICPC 2005年 D　問題](https://icpc.iisf.or.jp/past-icpc/domestic2005/D/D_ja.html) を簡単にした問題を解いてみましょう。

本来の問題（後日、課題５B（オプション課題）として出題予定）

* m (2以上３０以下）個の都市と、p（０以上）個の道がある
* 馬車チケットが n （１以上８以下）枚与えられている
* スタートとゴールの都市が与えられ、最短移動時間を求める問題。
* 道で直接つながった都市間は、馬車チケットを消費して移動することができる。その移動時間は、都市間の道の長さを、馬車チケットの数字で割った値。

簡単化した問題（課題３）

先ほどの問題の最後の項を以下のように変更します。

* 「修正前」道で直接つながった都市間は、馬車チケットを消費して移動することができる。その移動時間は、都市間の道の長さを、`2` で割った値。
* 「修正後」都市の移動に馬車チケットは不要。その移動時間は、都市間の道の長さを、`2` で割った値。

~~つまり、チケットを使う順番は気にせず、枚数だけ注意すればよい問題です。~~
チケットの使う順番も枚数も気にしなくてよい問題になりました。素直な最短経路問題になりました。

実は、「修正前」の設定でも「解ける」のですが、それなりに難しい問題になるのに、気づいていませんでした。
問題を簡単化したため、解答例も変更になります。

## プログラム解説

例によって、途中まで完成させてあります。

* 11-15 行目: 変数定義。
  * `#define INF INT_MAX` で、`INF` という定数を宣言しています。到達不能を表す値として利用してください（`int` と `double` で併用してもらうように、`DBL_MAX` でなく `INT_MAX` で統一しておきます。）
* 17-18 行目：入力データ
  * `int tickets[]`: チケット情報（課題１では使いません、0..(n-1) 要素に値が入っています）
  * `int road[][]`: road 情報。`road[i][j]` の値は、都市 `i+1`, `j+1` 間に道がある場合はその長さが、ない場合は`INF` が入っています。
* 20-38 行目: 初期化ルーチン（見る必要なし）
* 44-52 行目: 鎌田の準備した探索ノードのデータ構造
* 57-155 行目: 優先度キュー（実装済み） 
* 161 行目: solver が使うデータ構造
  * `priorityQ_t Q`: 優先度キュー
  * `TODO`: solver を完成させるのに必要な大域変数（配列）があったら、適時作成してください。
* 173-185 行目: メインルーチン
  * 引数と返り値情報は、プログラム中に記載
    * `a, b` は、スタートとゴールの都市番号です。
  * `TODO` solver 本体を完成させましょう。
* 187-255 行目: メイン関数（正誤チェック付き）
* 262-281 行目：デバッグ時用メイン関数（デバッグ時は、こちらを使ってくれてもよいかと。）

## 標準課題提出物

プログラム自身は 30行以内で完成するかと思います。
ただ、デバッグなど大変かもしれません。

1. 正解プログラム例の公開までは、一般の提出となります。以下を提出してください。
    * プログラムファイル
    * レポート：学番＋氏名＋実行結果（debug 出力が混ざっていても構いません）
    * アピールポイントがある人は、その旨解説入れてください。
    * ほとんどのデータで正解しているが、一部データでバグが取れない場合は、その旨記述して、考察を記載してください。
    * `sample.in` が全部正解していれば、「ほぼ正解」として扱うので、その時点で提出してもらって OK です。

2. 正解例を参考にレポートを提出する場合
    * まず、未完成でも、その自作プログラムを提出すること。
    * 自分が作成できなかった部分がどの部分か、正解例ではどのように実現されていたか、解説すること。
    * 正解プログラム例の実行を、デバッガなどでトレースし、正しく動作していることを説明すること。今回の例では、sample.in の最初の例について解説すれば OK です。

## デバッグアドバイス

まずは、sample.in の問題をきちんと解きましょう。
デバッガで動作を追っかけるとよいでしょう。

デバッグ用に、`mainD()` 関数を準備しておいたので、`main() → mainX()` にして、`mainD() → main()` に置き換えて、間違えた問題データだけを `debug.in` に入れて解いてみるとよいでしょう。

D.in で問題を間違えた場合は、当該問題とその回答を sample.in や sample0.ans 冒頭にコピーするなりして、デバッグするとよいでしょう。


## 課題５B（オプション課題）

余力のある人は本来の問題に取り組んでください。
難易度は、結構上がります。まず、解き方の基本方針を考えてみましょう。
解き方が分かれば、それほど難しい問題ではありません。
課題５B として後日解説しますが、それまでにできた人は BEEF 経由で提出してください。

* 提出物
    * プログラム
    * 実行結果
    * 基本的な考え方およびデータ構造の解説
